# 八大包装类
![](2025-12-24-21-08-46.png)
## 关系
![](2025-12-24-21-11-08.png)
![](2025-12-24-21-12-43.png)
![](2025-12-24-21-11-57.png)
## 装箱、拆箱
![](2025-12-24-21-14-46.png)
- tips
![](2025-12-24-21-23-18.png)
三元运算符是一个整体，返回值是最大类型的值，因而这里采纳的是double型并非int的范围
## 包装类和字符串相互转换
![](2025-12-24-21-29-35.png)
## integer类与character类的常用方法
![](2025-12-24-21-31-54.png)
## tip：关于valueOf
就比如说integer中，我们阅读源码发现，对于输入参数处理，在一个范围内它是返回值，否则返回一个new的对象
![](2025-12-27-16-03-33.png)
最后一个是F，都是new新对象了。valueOf面对不同包装类都有一定的缓存范围，否则返回一个新对象
![](2025-12-27-16-08-38.png)
但注意有基本类型，就是值比较，无需考虑
# string类
![](2025-12-27-16-10-52.png)
![](2025-12-27-16-11-49.png)
- string实现了serializable，说明其可以串行化。所有实现此接口的类都可以在网络传输
- 实现了comparable，说明可以相互比较。
- 列出来的只是常用的，还有其他的构造器去看手册

![](2025-12-27-16-21-01.png)
这里是指string本质是个类，而value数组是他的一个属性，存放字符串。而final修饰的是value，value是数组名，数组名本质是一串地址，因而他的final特性并非值常量而是指针常量。这个value不可再指向其他地址
## 两种创建方式与内存详情
![](2025-12-27-16-25-03.png)
![](2025-12-27-16-28-40.png)
注意，类中属性的内存分配要遵循我们之前学的规则
![](2025-12-27-16-45-08.png)
### intern方法
![](2025-12-27-16-39-49.png)
## 特性
![](2025-12-27-16-48-01.png)
![](2025-12-27-16-49-24.png)
![](2025-12-27-20-37-31.png)
这里是这样一个过程：编译器底层对Stringbuilder创建一个对象，然后这个对象里面自带一个空字符数组。我们将次字符数组.append(增添)上a和b的字符串。然后将这个字符数组通过tostring方法在堆中开辟一个新对象，然后赋予变量c，也就是说我们创建了两个对象，builder对象，和堆中String对象
![](2025-12-27-20-47-10.png)
![](2025-12-27-20-48-31.png)
String c = new StringBuilder().append(a).append(b).toString();
## 常见方法
![](2025-12-27-21-25-00.png)
![](2025-12-27-21-26-31.png)
![](2025-12-27-21-29-03.png)
![](2025-12-27-21-49-59.png)
## stringbuffer类
![](2025-12-27-21-53-28.png)
![](2025-12-27-21-54-30.png)
![](2025-12-27-22-01-05.png)
![](2025-12-27-22-10-08.png)
### 构造器
![](2025-12-27-22-14-31.png)
### string和stringbuffer相互转换
string->stringbuffer
![](2025-12-27-22-16-36.png)
stringbuffer->string
![](2025-12-27-22-17-59.png)
### 常用方法
![](2025-12-27-22-23-37.png)
![](2025-12-27-22-23-50.png)
![](2025-12-27-22-23-13.png)
![](2025-12-27-22-26-08.png)
## stringbuilder
![](2025-12-27-22-42-39.png)
![](2025-12-27-22-43-52.png)
![](2025-12-27-22-46-27.png)
![](2025-12-27-22-46-52.png)
## 三种的比较
![](2025-12-27-22-52-20.png)
![](2025-12-27-22-54-17.png)
## 练习
![](2025-12-28-21-34-12.png)
这里因为我们string属性value数组虽然可以改变，但privat权限导致你理论可以改变但无法获取。因而我们处理string时通常是把其转为一个可以随意更改的char数组/stringbuilder，修改后把这个传入string构造器里来构造一个新string对象替代原先的
![](2025-12-28-21-43-15.png)
![](2025-12-28-21-42-34.png)
这里需要做一个防护机制，防止数组越界。在只需要if判断合法参数范围的！就行了，正难则反
# Math
![](2025-12-27-22-57-30.png)
![](2025-12-27-22-58-46.png)
![](2025-12-27-23-02-50.png)
+1是因为强行转int需要向下取整
# Arrays
![](2025-12-28-18-19-50.png)
![](2025-12-28-16-41-58.png)
tostring输出格式就是[x,x,x,x]<br>
关于sort：首先他是地址传递，排序完影响原数组，其次，可以只传入一个数组参数，他便是从小到大排序。也可以通过传入数组和接口，对借口用匿名类重写compare方法，进行自定义排序。而这个的本质是return的值。当返回负值或零，他认为无需交换，否则就交换，使其保证是升序的。而我们通过操作return的表达式，来自定义排序
```
Arrays.sort(nums, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1 - o2; // 结果：1, 2, 5, 8
            }
        });
```
```
Arrays.sort(nums, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2 - o1; // 结果：8, 5, 2, 1
            }
        });
```
现阶段需要掌握的主要是升降序，更高级的以后有能力去看源码进行重写
- 一点例题
![](2025-12-28-18-47-22.png)
这里是book类，对double型属性price进行排序。注意他处理返回值的这个判断，可以套用

![](2025-12-28-17-21-22.png)         
![](2025-12-28-17-32-14.png)
![](2025-12-28-17-34-17.png)
![](2025-12-28-18-22-43.png)
# System
![](2025-12-28-18-51-22.png)
这里课件打错了，是currentTimeMillis
![](2025-12-28-18-54-17.png)
类似于retrun 0
![](2025-12-28-19-00-06.png)
重点是搞明白这五个参数含义。这里一开始src=1 2 3 dest=0 0 0
# BigInteger和BigDecimal
![](2025-12-28-19-14-42.png)
![](2025-12-28-19-17-41.png)
BIgDecimal同上，但要注意除法时若有无限循环小数结果要设置精度
![](2025-12-28-19-23-13.png)
# 日期类
## Date（第一代）
![](2025-12-28-19-24-24.png)
![](2025-12-28-19-25-05.png)
![](2025-12-28-19-32-05.png)
![](2025-12-28-19-32-25.png)
这里格式化不能瞎写，注意这里年月日和时分秒空两格，时分秒与星期空一格
![](2025-12-28-19-30-17.png)
![](2025-12-28-19-59-42.png)
这里格式一致是指年月日等等数值不能缺少多出
## Calendar（第二代）
![](2025-12-28-20-02-17.png)
![](2025-12-28-20-03-20.png)
![](2025-12-28-20-05-04.png)
![](2025-12-28-20-05-41.png)
注意月份要加一，若想要24小时制的hour，这里用Calendar.HOUR_OF_DAY来获取字段
## 第三代日期
![](2025-12-28-20-13-12.png)
![](2025-12-28-20-15-26.png)
![](2025-12-28-20-14-05.png)
自己去查手册<br>
格式化与Date很相似
![](2025-12-28-20-24-49.png)
![](2025-12-28-20-26-49.png)
时间戳：为了解决人类的时刻有时区的影响，我们采用了1970年1月1日 00:00:00 (格林威治标准时间 UTC) 这一刻作为宇宙秒表，宏观定义了绝对时间。这也就引出了Instant类，一类面向绝对时间，也可以说是最适合面向机器的时间。而前面我们学的三种类是面向于人类群体的
![](2025-12-28-20-40-41.png)
