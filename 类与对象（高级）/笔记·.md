# 类变量(静态变量)
此类所有对象共享的一个变量，在类加载随着类的加载而创建，也就是没有创建对象也会存在类变量
![](2025-12-17-21-01-42.png)
## 细节
![](2025-12-17-21-05-23.png)
![](2025-12-17-21-06-19.png)
# 类方法
![](2025-12-17-21-10-53.png)
![](2025-12-17-21-12-01.png)
## 注意事项
![](2025-12-17-21-32-52.png)
![](2025-12-17-21-36-53.png)
# main方法
![](2025-12-17-21-51-18.png)
![](2025-12-17-21-53-48.png)
注意哦，这里说的静态变量非静态变量是在publc static void main(){}与上面那一坨中间，就是类比普通的类的形式，属性和方法该在的地方。
## idea中使用args数组方法
![](2025-12-17-21-58-04.png)
Program arguments的地方
# 代码块
![](2025-12-17-22-00-34.png)
相当于另一种形式的构造器，解决了构造器中代码复用问题
## 细节
![](2025-12-17-22-08-59.png)
注意继承中static类加载规则父类先加载（代码块先运行），后子类<br>
而普通代码块可以看做是构造器的延展。构造器被调用，一定代码块就会被调用
![](2025-12-18-15-38-46.png)
![](2025-12-18-15-36-59.png)
若类中代码块在下，方法在上输出会前后颠倒。这就是顺序<br>
而总体上静态>普通>构造器。也就是先加载类再创建对象。创建对象要从属性方法代码块初始化开始，到构造器（遇见了父类就套娃，而构造器暗中包括super构造器和普通代码块的调用）
![](2025-12-18-15-47-36.png)
![](2025-12-18-15-58-37.png)
# 单例设计模式
应用于这个类一定从头到尾就一个对象
![](2025-12-18-16-14-43.png)
## 饿汉式
无论有没有使用在一开始类被加载就已经创建这个对象，就可能造成资源浪费
![](2025-12-22-15-29-22.png)
下面是代码
![](2025-12-22-15-32-29.png)
## 懒汉式
![](2025-12-22-16-27-25.png)
## 比较
![](2025-12-22-16-28-47.png)
# final
可以修饰类、方法、属性、和局部变量（方法里面的变量）
![](2025-12-22-16-33-59.png)
## 注意事项
![](2025-12-22-16-40-22.png)
定义同时一定要赋值。若没有一句完成初始化声明，则可以在构造器和代码块这种你加载时必然完成同时赋值的地方进行补充赋值。<br>
4点是指你一个类被final修饰不能被继承但可以对此类实例化
![](2025-12-22-16-45-55.png)         
7点是指搭配使用使得你既可以不实例一个对象再调用属性，同时调用这个值不会进行静态的一系列加载<br>
8点上那一堆都无法进行继承
# 抽象类
应用于暂时不清楚此方法如何实现的类
![](2025-12-22-17-06-49.png)
子类就像正常重写一样去
## 注意事项
![](2025-12-22-17-09-55.png)
![](2025-12-22-17-12-06.png)
![](2025-12-22-17-13-14.png)
# 接口
![](2025-12-22-18-30-45.png)
也就是说接口中方法有三种：静态、抽象、默认实<br>
可以把把接口理解设计一个产品的都有哪些规格，而具体规格的实现由下面的类的来实现。在实际中会出现产品经理负责接口的编写，把接口的内容实现交给具体程序员来编写
## 注意事项
![](2025-12-22-18-52-14.png)
首先，实现接口的类方法不可除public以外的修饰（认为你缩小了接口范围），其次有快捷键可以在写实现接口类一键生成所有抽象方法的头（alt+enter）
![](2025-12-22-19-13-03.png)
一个类实现多个接口实例
![](2025-12-22-19-05-34.png)
![](2025-12-22-19-34-39.png)
以上三种都编译通过，说明着接口既大致遵守着继承的规则，又遵循着静态的规则 
## 接口与继承类的区别
![](2025-12-22-19-40-25.png)
## 接口的多态特性
类似于我们在继承中的向上转型。多态数组的东西 
![](2025-12-22-19-49-34.png)
![](2025-12-22-19-50-38.png)
第二条那个call也就是继承子类想调用特有方法需要向下转型<br>
![](2025-12-22-20-00-23.png)

一点小知识点，类似于一个变量在子类父类同时定义在调用时的问题在接口中的体现

### 1. 场景 A：类实现了接口，且类自己也定义了同名变量

* **结论：** **不报错**。
* **规则：** 类自己定义的变量会“遮盖”住接口里的静态常量（即变量隐藏 Variable Hiding）。
* **调用方式：**
* 调用类自己的：直接写 `x` 或 `this.x`。
* 调用接口的：必须用 `接口名.x` (因为接口变量默认是 `static` 的)。



```java
interface A {
    int x = 100; // 默认是 public static final
}

class B implements A {
    int x = 200; // 类自己定义一个同名变量，完全没问题

    void show() {
        System.out.println(x);      // 输出 200 (默认就近原则，取类自己的)
        System.out.println(this.x); // 输出 200 (显式指代当前对象)
        System.out.println(A.x);    // 输出 100 (想要接口的，必须显式用接口名调用)
    }
}

```

### 2. 场景 B：类同时继承父类和实现接口，且父类与接口有同名变量

* **前提：** 子类 C 自己**没有**定义变量 `x`。
* **结论：** **编译报错！** (`Reference is ambiguous` / 引用不明确)
* **原因：** 当直接使用 `x` 时，编译器无法判断你到底想要父类的成员变量，还是接口的静态常量，产生了二义性。
* **解决方法：** 必须在代码中显式指定来源。

```java
interface A {
    int x = 100;
}

class Father {
    int x = 50;
}

// 类 C 既继承 Father 又实现 A，且 C 自己没有写 int x
class C extends Father implements A {
    void show() {
        // System.out.println(x); 
        // ❌ 编译错误：对 x 的引用不明确 (Reference to x is ambiguous)
        // 编译器疑惑：Father里有x，接口A里也有x，且都能访问，你到底指哪一个？
        
        // ✅ 正确写法：必须显式区分
        System.out.println(super.x); // 输出 50 (明确获取父类的)
        System.out.println(A.x);     // 输出 100 (明确获取接口的)
    }
}

```
###### 笔记最多的一集
# 内部类
![](2025-12-22-20-42-47.png)
## 内部类分类
![](2025-12-22-20-45-11.png)
### 局部内部类
![](2025-12-22-20-53-08.png)
在方法/或者代码块中定义一个类，然后可以去在本方法/代码块中声明一个后进行调用
### 匿名内部类
```
class Outer04 { //外部类
private int n1 = 10;//属性
public void method() {//方法
//基于接口的匿名内部类
//老韩解读
//1.需求： 想使用 IA 接口,并创建对象
//2.传统方式，是写一个类，实现该接口，并创建对象
//3.老韩需求是 Tiger/Dog 类只是使用一次，后面再不使用
//4. 可以使用匿名内部类来简化开发
//5. tiger 的编译类型 ? IA
//6. tiger 的运行类型 ? 就是匿名内部类 Outer04$1
/*
 我们看底层会分配类名Outer04$1
 lass Outer04$1 implements IA {
@Override
public void cry() {
System.out.println("老虎叫唤...");
}
}
*/
//7. jdk 底层在创建匿名内部类 Outer04$1,立即马上就创建了 Outer04$1 实例，并且把地址
// 返回给 tiger
//8. 匿名内部类使用一次，就不能再使用
IA tiger = new IA() {
@Override
public void cry() {
System.out.println("老虎叫唤...");
}
};
System.out.println("tiger 的运行类型=" + tiger.getClass());
tiger.cry();
tiger.cry();
tiger.cry();
// IA tiger = new Tiger();
// tiger.cry();
//演示基于类的匿名内部类
```