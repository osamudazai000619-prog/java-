# 集合
![](2025-12-29-11-37-57.png)
## 框架（背）
集合类分为两大类：单列集合、双列集合
![](2025-12-29-11-40-16.png)
![](2025-12-29-11-47-56.png)
![](2025-12-29-11-54-51.png)
# 单列集合
K-V中，V全部用present占位，K是我们输入的值
## Collection接口
集合就是一个巨大的向上转型
![](2025-12-29-11-58-00.png)
### 方法
![](2025-12-29-11-59-04.png)
![](2025-12-29-12-05-01.png)
![](2025-12-29-13-42-30.png)
![](2025-12-29-13-44-35.png)
### 遍历
#### 迭代器法
只要继承了Collection接口的都可以运用迭代器Iterator（一个方法）遍历
![](2025-12-29-13-47-22.png)    
![](2025-12-29-13-48-59.png)
![](2025-12-29-13-50-07.png)
![](2025-12-29-13-53-06.png)
注意当遍历结束，此迭代器就指向最后一个元素，想要再次遍历需要重置迭代器，也就是再次调用方法：iterator=co.iterator（）；<br>
迭代器快捷键itit。
#### for循环增强
可运用于集合和数组，底层依旧是调用迭代器。注意这里写：以左最好是object类，一般集合里面不止一种类型元素
![](2025-12-29-14-01-57.png)
![](2025-12-29-13-59-41.png)
快捷键I
## list接口
![](2025-12-29-14-08-48.png)
![](2025-12-29-15-13-52.png)
下标索引不是[]是()
![](2025-12-29-14-11-29.png)
![](2025-12-29-15-16-33.png)
![](2025-12-29-15-18-11.png)
### 遍历
也是迭代器，for增强循环，然后还有传统的for循环（利用get方法）

- 注意
![](2025-12-29-15-31-44.png)
我们可以看到get返回对象默认是object型，需要自己进行一个向下转型。
![](2025-12-29-15-35-32.png)
### 源码分析
![](2025-12-29-15-36-42.png)
transient关键字修饰后该属性不会被序列化，此数据不会被二进制化，也就是无法被网络运输，<br>
听不懂，源码交给未来的我
## vector类（实现list接口）
![](2025-12-29-15-58-44.png)
### arraylist与vector比较
![](2025-12-29-15-59-47.png)
## LinkedList类
![](2025-12-29-16-04-42.png)
### 底层实现
![](2025-12-29-20-40-03.png)
这里链表集合包括无数个node节点（类）以及指向头、尾的指针
![](2025-12-29-20-48-48.png)
![](2025-12-29-20-49-16.png)
![](2025-12-29-20-49-31.png)
### 方法
![](2025-12-29-21-07-55.png)
### arraylist与linkedlist比较
![](2025-12-29-21-09-46.png)
## set接口
![](2025-12-29-21-12-06.png)
元素不能重复，null也只能存一个，然后顺序不是存入顺序
## hashset
![](2025-12-29-21-17-47.png)

![](2025-12-29-21-23-40.png) 
### 底层实现
单项链表数组（数组中每个元素是一串链表）+哈希表。<br>
他是先去把你添加的元素求出哈希code，再避免碰撞进一步计算出哈希值作为他数组的索引值。得到索引值后会进行判断：<br>
!!先判断一下数组是否为空（懒加载），空则初始扩容16，临界为size*加载因子（0.75）<br>
1、若此哈希值所在索引为空，直接放入此元素（会放入后判断是否到达临界值来进行扩容）<br>
2、若此哈希值所在索引不为空:<br>
a、去判断此索引下链表第一个元素hash值和key是否相同。（查重）<br>
b、去判断是否是红黑树，是则按红黑树法则插入（法则未学习）<br>
c、那就一定是链表了。从这个索引中链表第二个索引开始去查找，直到抵达链表的尾巴。发现重则break，到尾则把该值添加在表尾同时判断是否要扩容(到达8)若是则再判断是否扩展为红黑树还是数组扩容<br>
！！！这里查重都运用了equal方法，可以自己去重写来自定义重复的定义（哪些重复才算同一物品）
![](2025-12-30-15-27-01.png)
扩容机制：
![](2025-12-31-22-15-30.png)
懒加载，每次数组扩为他的二倍，但临界值是size（不是16）*0.75，这个因子是计算出内存查找平衡的最佳因子数。而链表不会扩容，当该索引开始添加第一个链表元素，这个索引链表的最大值就是8。但进入2、c情况发现8链表满掉时，就会考虑是进行数组扩容还是红黑树扩展。只要数组元素不到64就进行数组扩容，这时因为数组size变化，哈希值运算式中一个量是数组size会变化致使哈希值的同一个元素运算值在数组扩容后也会不同，也就实现了此后相同哈希值的元素不会聚集在原先那个链表，而是换一个索引一个个往后堆链表。这就避免了聚集。而当数组元素到64，就会扩展为树。而数组会继续扩容，只是之后每个索引都是红黑树了
- 实际应用的时候通常会重写equal方法，满足业务需求构建哈希表（idea可以快捷重写）。但注意，你在根据业务设计哈希表时，一定要重写存入的数据及其子类相关（连锁反应。比如hash表里面的是类a，a中一个属性是类b的对象。当设计的哈希表是基于b属性进行hashcode的，外层a类hashcode运算重写为调用参数属性b，而因为调用的是一个类，连锁反应会去查询该类的hashcode方法是否被重写，是何种规则，来进行运算。这时我们通常会根据业务需求吧内部属性的类方法也重写掉）getClass()的hashcode()方法。不然hashcode会默认基于地址进行计算。
- 重写hashcode的原因是，只有hashcode运算使其分配在同一个各自才会被equal判断是否是同一物品。因而我们通常重写hashcode的运算参数，使那几个参数是我们判断他们是同一对象的参数。而为什么hashcode同了也不能判断是同一对象是因为：不同的参数可能运算出相同的hash值，无法做到百分百的一对一。
```
class MyDate {
    private int year;
    private int month;
    private int day;

    public MyDate(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }

    // 1. 重写 equals (你说的思路完全正确)
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        MyDate myDate = (MyDate) o;
        return year == myDate.year &&
               month == myDate.month &&
               day == myDate.day;
    }

    // 2. 【关键】必须重写 hashCode
    // 只要年月日一样，计算出的整数必须一样
    @Override
    public int hashCode() {
        // 简单写法，或者用 Objects.hash(year, month, day)
        return Objects.hash(year, month, day); 
    }
}
```
## linkedhashset
![](2026-01-03-15-58-18.png)
继承了hashset的类
![](2026-01-03-15-59-10.png)
储存加密但存取顺序不变的特性
![](2026-01-03-16-02-32.png)
### 源码阅读
他的底层通过linkedhashmap实现，是hashmap的子类
![](2026-01-03-16-21-45.png)
entry类（linkedhashmap节点类）继承了node（hashmap的节点类）并添加了after，before指针用于在纵向（数组每个元素）构建双向链表，同时（！！）横向每个元素仍用next构建横向链表处理碰撞问题。而其他等等与hashset一致
# 双列集合（更常用）
## map接口
![](2026-01-16-16-26-19.png)
![](2026-01-03-16-45-54.png)
key要是有重复会进行替换（key带value地替换）
![](2026-01-16-14-56-44.png)
这里entry是指map.entry接口，不是linkedhashmap里面的那个entry
![](2026-01-16-15-06-48.png)
![](2026-01-16-15-12-33.png)
为了方便查询遍历，我们需要借用entryset的方法。调用方法时，node向上转型成entry并且打包进entryset类、。这同时也是懒加载。
注意entryset中都是引用，指向node。也就是说数据不存储。
![](2026-01-16-16-06-38.png)
### 常用方法
![](2026-01-16-15-18-51.png) 
![](2026-01-16-15-21-10.png)
这里size是指对数
### 六大遍历方法
![](2026-01-16-15-48-18.png)
![](2026-01-16-15-25-56.png)
![](2026-01-16-15-29-02.png)
![](2026-01-16-15-42-39.png)
![](2026-01-16-15-44-19.png)
## hashmap接口（前面已经在在hashset底层中讲过了）
![](2026-01-16-16-15-17.png)
![](2026-01-16-16-17-04.png)
这里hash值计算还是，object类默认用地址算hash，string用内容，也可以自定义来确定什么定义为这个map里面的“相同值”
## hashtable接口
![](2026-01-16-16-35-45.png)
![](2026-01-16-16-35-26.png)
![](2026-01-16-16-38-31.png)
这里<<1+1翻译成人话就是x*2+1
### hashmap和hashtable的对比
![](2026-01-16-16-39-27.png)
### properties接口
![](2026-01-16-16-40-37.png)
![](2026-01-16-16-53-32.png)
![](2026-01-16-16-55-19.png)
![](2026-01-16-16-55-58.png)
# 集合的选择
![](2026-01-16-16-59-44.png)
# treeset和treemap
都是无参时会数字从小到大，有参传入一个比较器就可以自定义排序
![](2026-01-16-19-00-57.png)
注意treemap只对key处理
![](2026-01-16-20-29-35.png)
# Collections工具类
![](2026-01-16-20-04-13.png)
![](2026-01-16-20-08-10.png)
![](2026-01-16-20-08-57.png)
![](2026-01-16-20-10-31.png)
![](2026-01-16-20-11-06.png)
![](2026-01-16-20-13-15.png)
![](2026-01-16-20-17-18.png)
list频率都可以，set型只有0/1
![](2026-01-16-20-18-41.png)
![](2026-01-16-20-19-32.png)
