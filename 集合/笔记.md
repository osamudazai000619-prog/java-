# 集合
![](2025-12-29-11-37-57.png)
## 框架（背）
集合类分为两大类：单列集合、双列集合
![](2025-12-29-11-40-16.png)
![](2025-12-29-11-47-56.png)
![](2025-12-29-11-54-51.png)
# 单列集合
## Collection接口
集合就是一个巨大的向上转型
![](2025-12-29-11-58-00.png)
### 方法
![](2025-12-29-11-59-04.png)
![](2025-12-29-12-05-01.png)
![](2025-12-29-13-42-30.png)
![](2025-12-29-13-44-35.png)
### 遍历
#### 迭代器法
只要继承了Collection接口的都可以运用迭代器Iterator（一个方法）遍历
![](2025-12-29-13-47-22.png)    
![](2025-12-29-13-48-59.png)
![](2025-12-29-13-50-07.png)
![](2025-12-29-13-53-06.png)
注意当遍历结束，此迭代器就指向最后一个元素，想要再次遍历需要重置迭代器，也就是再次调用方法：iterator=co.iterator（）；<br>
迭代器快捷键itit。
#### for循环增强
可运用于集合和数组，底层依旧是调用迭代器。注意这里写：以左最好是object类，一般集合里面不止一种类型元素
![](2025-12-29-14-01-57.png)
![](2025-12-29-13-59-41.png)
快捷键I
## list接口
![](2025-12-29-14-08-48.png)
![](2025-12-29-15-13-52.png)
下标索引不是[]是()
![](2025-12-29-14-11-29.png)
![](2025-12-29-15-16-33.png)
![](2025-12-29-15-18-11.png)
### 遍历
也是迭代器，for增强循环，然后还有传统的for循环（利用get方法）

- 注意
![](2025-12-29-15-31-44.png)
我们可以看到get返回对象默认是object型，需要自己进行一个向下转型。
![](2025-12-29-15-35-32.png)
### 源码分析
![](2025-12-29-15-36-42.png)
transient关键字修饰后该属性不会被序列化，此数据不会被二进制化，也就是无法被网络运输，<br>
听不懂，源码交给未来的我
## vector类（实现list接口）
![](2025-12-29-15-58-44.png)
### arraylist与vector比较
![](2025-12-29-15-59-47.png)
## LinkedList类
![](2025-12-29-16-04-42.png)
### 底层实现
![](2025-12-29-20-40-03.png)
这里链表集合包括无数个node节点（类）以及指向头、尾的指针
![](2025-12-29-20-48-48.png)
![](2025-12-29-20-49-16.png)
![](2025-12-29-20-49-31.png)
### 方法
![](2025-12-29-21-07-55.png)
### arraylist与linkedlist比较
![](2025-12-29-21-09-46.png)
## set接口
![](2025-12-29-21-12-06.png)
元素不能重复，null也只能存一个，然后顺序不是存入顺序
## hashset
![](2025-12-29-21-17-47.png)

![](2025-12-29-21-23-40.png) 