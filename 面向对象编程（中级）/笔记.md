# IDEA
## 文件
scr——原码<br>
out——编译后的<br>
# 包
![](2025-12-12-15-41-14.png)
其本质其实就是文件夹，类似于c++命名空间。包内可以套子包
## 包的命名
### 规则
![](2025-12-12-15-50-00.png)
### 规范
![](2025-12-12-15-51-20.png)
## 常见的包
![](2025-12-12-15-52-49.png)
Array.sort(数组); 排序，在util.Array包里面
## 引入包
import java.util.Scanner 引入包中在某个类<br>
import java.util.* 引入此包中所有类
## 声明包
声明当前类在哪个包：packge写到包名，不用写出类名

![](2025-12-12-16-01-32.png)
## 关于类定义的补充
![](2025-12-12-16-03-08.png)
# 访问修饰符
![](2025-12-12-16-04-08.png)
![](2025-12-12-16-05-25.png)
# 封装
![](2025-12-12-17-06-48.png)
![](2025-12-12-17-09-43.png)
当需要对构造器进行保护（封装后，利用构造器可以绕过方法赋值），在提供方法同时，把方法写到构造器里面（

```
Person(String name...){
setName(name);
...
}
```

）
# 继承
解决代码复用问题
![](2025-12-13-20-19-39.png)
## 细节
![](2025-12-13-21-13-17.png)
默认也在子类无法访问，但大部分子类与父类在同一包下，因而可以访问。继承不一定能访问。
![](2025-12-13-21-18-24.png)
第三条指的是当父类创建有参构造器，又没设定无参构造器会报错。必须在父类构造器给属性都赋值<br>
但是若你父类无无参构造器，只要子类在处理时能把父类初始化搞好，也不会报错
![](2025-12-15-12-58-50.png)
这里运用子类构造器把父类初始化了，就算父类没有无参构造器也OK。关键就是确保，子类创建，父类的属性一定不能为空
![](2025-12-13-21-26-22.png)
![](2025-12-13-21-25-16.png)
super只能在构造器中
![](2025-12-13-21-34-03.png) 
![](2025-12-13-21-33-46.png)
![](2025-12-13-21-53-29.png)
## 内存
方法池加载从子到父，堆中开辟空间从父到子，在一片内存区。最后返回主地址给子类名，因而子类父类变量名可以重名，因为是不同内存空间。<br>
重名调用规则
![](2025-12-13-21-43-41.png)
当查找但无法访问也不会再去父级查找
# super
![](2025-12-14-13-33-48.png)
在查找中不限于上一级父类，还可以网上往上查找。
# super与this比较
![](2025-12-14-14-54-56.png)
# 方法重写/覆盖
![](2025-12-14-14-58-23.png)
![](2025-12-14-14-59-45.png)
- object是所有类的父类
# 重写和重载区别
![](2025-12-15-12-53-18.png)
# 多态
![](2025-12-15-13-25-08.png)
![](2025-12-15-13-33-09.png)
![](2025-12-15-13-32-20.png)
注意是父类指向子类<br>
同时传参也有相同特点。当形参类型是animal，传参添加animal子类也没关系。
## 向上转型
![](2025-12-15-13-56-01.png)
也就是说只能调用子类父类都有的方法，（当然正常调用父类的方法也OK，就不涉及多态了）但方法实现是按照子类的，也就是按照运行类型，而属性依照编译类型，也就是依旧是父类 
## 向下转型
![](2025-12-15-14-07-45.png)
他是在向上转型后才会有的，满足第二条，转型后由父类引用（编译类型）变为子类引用，运行也变成cat。注意这里子类相当于新建了一个变量名指向这个内存。
![](2025-12-15-14-16-40.png)
同样可以用于这种隐形表明类的转换
## instanceOf
比较操作符，返回true false用于判断对象的运行类型是否是xx类型或xx类型的子类<br>
对象名 instanceOf 类名  
## java的动态绑定机制
![](2025-12-15-14-31-34.png)
第一点对应着getI()，方法调用的是这个方法内存中的对象属性（运行类型），第二点对应着return i，调用的是编译类型<br>
用getClass()来查看运行类型
## 多态的应用
### 多态数组
![](2025-12-15-17-39-32.png)
![](2025-12-15-17-43-05.png)
当需要调用子类特有方法时再向下转型
### 多态参数
函数形参是父类，允许实参传入为子类吗.
# object类详解
无需导入的一个类
## ==与equals方法
![](2025-12-15-19-34-21.png)
==前提是两边类型相同哦
![](2025-12-15-20-09-43.png)
equal本身是比较地址，object父类下子类（如string intrger）的equal方法都进行了重写，使之实现比较值的功能<br>
自己创建的类常常可以自己创建类似的equal方法实现对自己类某些值的值比较
## hashCode
![](2025-12-15-20-31-38.png)
## toString
![](2025-12-15-20-34-34.png)
全类名=包名+类名<br>
一般类重写会默认重写为陈列类属性名和值
## finalize
![](2025-12-15-20-39-44.png)
相当于对于野指针的自动回收。但注意，并非出现一个垃圾就回收，有特定算法。面试用，开发几乎不会看
# 断点调试
![](2025-12-15-20-46-43.png)
![](2025-12-15-20-49-44.png)
可以用debug的断点机制去看复杂的代码
# 零钱通实战
## 当前时间
最开始Date date=null;<br>
何时用的时候date=new Date();显示出来当前时间<br>
呈现出来是国外显示方法，改成不同格式便可在最前面声明后SimpleDateFormat sdf =new SimpleDateFormat("yyyy-MM-dd HH:mm");格式化