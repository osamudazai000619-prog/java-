# IDEA
## 文件
scr——原码<br>
out——编译后的<br>
# 包
![](2025-12-12-15-41-14.png)
其本质其实就是文件夹，类似于c++命名空间。包内可以套子包
## 包的命名
### 规则
![](2025-12-12-15-50-00.png)
### 规范
![](2025-12-12-15-51-20.png)
## 常见的包
![](2025-12-12-15-52-49.png)
Array.sort(数组); 排序，在util.Array包里面
## 引入包
import java.util.Scanner 引入包中在某个类<br>
import java.util.* 引入此包中所有类
## 声明包
声明当前类在哪个包：packge写到包名，不用写出类名

![](2025-12-12-16-01-32.png)
## 关于类定义的补充
![](2025-12-12-16-03-08.png)
# 访问修饰符
![](2025-12-12-16-04-08.png)
![](2025-12-12-16-05-25.png)
# 封装
![](2025-12-12-17-06-48.png)
![](2025-12-12-17-09-43.png)
当需要对构造器进行保护（封装后，利用构造器可以绕过方法赋值），在提供方法同时，把方法写到构造器里面（

```
Person(String name...){
setName(name);
...
}
```

）
# 继承
解决代码复用问题
![](2025-12-13-20-19-39.png)
## 细节
![](2025-12-13-21-13-17.png)
默认也在子类无法访问，但大部分子类与父类在同一包下，因而可以访问。继承不一定能访问。
![](2025-12-13-21-18-24.png)
第三条指的是当父类创建有参构造器，又没设定有参构造器会报错。必须在父类构造器给属性都赋值
![](2025-12-13-21-26-22.png)
![](2025-12-13-21-25-16.png)
super只能在构造器中
![](2025-12-13-21-34-03.png) 
![](2025-12-13-21-33-46.png)
![](2025-12-13-21-53-29.png)
## 内存
方法池加载从子到父，堆中开辟空间从父到子，在一片内存区。最后返回主地址给子类名，因而子类父类变量名可以重名，因为是不同内存空间。<br>
重名调用规则
![](2025-12-13-21-43-41.png)
当查找但无法访问也不会再去父级查找
# super
![](2025-12-14-13-33-48.png)
在查找中不限于上一级父类，还可以网上往上查找。
# super与this比较
![](2025-12-14-14-54-56.png)
# 方法重写/覆盖
![](2025-12-14-14-58-23.png)
![](2025-12-14-14-59-45.png)
- object是所有类的父类